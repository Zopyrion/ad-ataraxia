const { Remarkable } = require('remarkable');
const meta = require('remarkable-meta');
const sidenote = require('../components/sidenote.js')
const fs = require('fs');
const md = new Remarkable();
md.inline.ruler.enable([
    'footnote_inline',
    'ins',
    'mark',
    'sub',
    'sup'
]);
md.use(sidenote);
md.use(meta)


const PATH = "../autogen/";
const METADATA_PATH = PATH + "metadeta.json"
const CONTENT_PATH = PATH + "content.json"
const COMMENT = "THIS IS A FILE AUTOGENERATED BY run.js"

const metadata = {comment: COMMENT,
                    all: {},
                    sorted: {},
                    routes: {}
                }
const content = {comment: COMMENT}


function process_file(path, file){
    const buffer = fs.readFileSync(path + file);
    const plaintext = buffer.toString();

    const res = md.render(plaintext);
    const data = md.meta

    const title = data['title']

    metadata['all'][title] = data
    metadata['all'][title]['file'] = file

    content[title] = plaintext
}

async function process(){
    const path = "../posts/";
    try {
        const files = await fs.promises.readdir(path);
        for(const file of files) {
            process_file(path, file)
        }
    } catch( e ) {
        console.error("Error: ", e);
    }
}

async function run(){
    await preload()
    await process()
}

async function preload(){
    const res = JSON.parse(fs.readFileSync(METADATA_PATH, 'utf8'));
    const routes = res['routes']
    metadata['routes'] = routes
}

function cleanup(){

    // Sort all blog entries by date
    let sortedBlogs = null
    const list = []
    for (const [key, value] of Object.entries(metadata['all'])) {
        list.push(value)
    }
    sortedBlogs = list.sort((a, b) => b.date - a.date)
    metadata['sorted']['all'] = []
    for (const index in sortedBlogs) {
        const title = sortedBlogs[index]['title'];

        const tags = metadata.all[title].tags;

        metadata['sorted']['all'].push(title)

        for(const tag of tags){
            if(!(tag in metadata['sorted'])){
                metadata['sorted'][tag] = []
            }
            metadata['sorted'][tag].push(title)
        }
    }

    // Create url for any new entries
    const routes = metadata['routes']
    const uniques = []
    for (const [, value] of Object.entries(routes)) {
        uniques.push(value)
    }
    for (const title in metadata['all']) {
        if(!(title in routes)){
            routes[title] = createUrl(uniques)
        }
    }

    // Create mappings used by react router
    metadata['mappings'] = {}
    for (const [key, value] of Object.entries(routes)) {
        metadata['mappings'][value] = key
    }

    // Write updated metadata to JSON
    const data = JSON.stringify(metadata,null, 4);
    const html = JSON.stringify(content,null, 4);
    fs.writeFileSync(METADATA_PATH, data);
    fs.writeFileSync(CONTENT_PATH, html);

    console.log("~Metadata file has been built")
}

function createUrl(uniques) {
    const min = Math.ceil(10000);
    const max = Math.floor(99999);
    let res = Math.floor(Math.random() * (max - min + 1)) + min;

    while(res in uniques){
        res = Math.floor(Math.random() * (max - min + 1)) + min;
    }
    uniques.push(res)
    return res;
}


run().then(r => cleanup())

